#!/bin/bash
set -eo pipefail
#
# This script processes a list of domains to check which nameservers
# are used. If a list of IPs is given it will also check if the
# IPs are pointing to the domain or not.
#

green='\033[0;32m'
red='\033[0;31m'
nc='\033[0m' #no color
output_dir=result-$(date +%F)

usage() {
   cat << HEREDOC

   Usage: $(basename "$0") [-d domain.list]

   optional arguments:
     -h, --help           show this help message and exit
     -o, --output-dir DIR directory to store results in
     -i, --iplist FILE    file containing ipv4 addresses per line
     -6, --ipv6list FILE  file containing ipv6 addresses per line
     -w, --match-www      check if www prefix matches domain A and AAAA records

HEREDOC
	exit 0
}

check_file_existence() {
	[[ -f "$1" ]] || (echo "File '${1}' does not exist" && exit 1)
}

make_output_dir() {
	declare output_dir="$1"
	if [[ -d "$output_dir" ]]; then
		while read -p "Output dir '$(basename "$output_dir")' exists, remove it and start over? (y/n) " answer 
		do
			#echo "Output dir '$output_dir' exists, remove it and start over? (y/n) " answer 
			case ${answer:0:1} in
				y|Y ) rm -rf "$output_dir"; main;;
				n|N ) exit 0;;
				* ) echo "Please answer yes or no.";;
			esac
		done

	else
		mkdir -p "$output_dir"
		cd "$output_dir"
	fi
}

linecount() {
	wc -l "$1"|cut -d' ' -f1
}

filecleanup() {
	#check for empty lines and remove them
	grep -qc '^$' "$domains_list" && sed -i '/^$/d' "$domains_list" && echo -e "${red}[Cleanup]${nc} Removed blank lines from $domains_list"

	#check if the file is sorted propertly if not, do so
	sort --check=quiet "$domains_list" || ( sort "$domains_list" --output "$domains_list" && echo -e "${red}[Cleanup]${nc} Sorted $domains_list" )

	#check for dupes and remove them
	uniques=$(uniq -cd "$domains_list")
	if [[ ! -z "$uniques" ]]
	then
		sort --unique "$domains_list" --output "$domains_list"
		echo "$uniques" >> "$output_dir"/duplicate_domains.txt
		echo -e "${red}[Cleanup]${nc} Removed duplicates: $(linecount "$output_dir"/duplicate_domains.txt) (see $output_dir/duplicate_domains.txt for a list)"
	fi

}

fetch_dns_records() {
	declare recordtype="$1" domains_list="$2"

	if [[ ! -e fetch_"$recordtype"_result.txt ]]; then
		echo "Scanning $(linecount "$domains_list") domains for $recordtype records..."
		while IFS= read -r domain
		do
			dig "$recordtype" +noall +answer "$domain" >> fetch_"$recordtype"_result.txt &
		done < "$domains_list"
		wait
	else
		echo "Found fetch_${recordtype}_result.txt, using as cache"
	fi
}

analyse_dns_records () {
	declare recordtype=$1
	case $recordtype in
		NS)
			while IFS= read -r domain
			do
				if grep -qcw "$domain" fetch_NS_result.txt;
				then
					echo "$domain" >> NS/resolving_domains.txt
					echo "$domain" >> "NS/$(grep -w "$domain" fetch_NS_result.txt|awk '{print $5}'|awk -F. '{print $2}'|sort|uniq).domainlist"

				else
					echo "$domain" >> NS/non_resolving_domains.txt
				fi

			done < "$domains_list"
			wait

			echo "Nameserver distribution:"
			wc -l NS/*.domainlist
			;;

		A)
			grep -f "$ips_list" fetch_A_result.txt >> domains_aligned.txt
			grep -vf "$ips_list" fetch_A_result.txt >> domains_unaligned.txt
			;;

		AAAA)
			grep -f "$ipv6_list" fetch_AAAA_result.txt >> domains_aligned_IPV6.txt
			grep -vf "$ipv6_list" fetch_AAAA_result.txt >> domains_unaligned_IPV6.txt
			;;
	esac
}

match_WWW_to_non_WWW() {
	echo todo
}

	echo -e "Resolving domains    : ${GREEN}$(linecount NS/resolving_domains.txt)${NC}"
	if [ -e NS/non_resolving_domains.txt ]; then
		echo -e "Non-resolving domains: ${RED}$(linecount NS/non_resolving_domains.txt)${NC}"
printSummary() {
	fi

	if [ -e A/aligned_domains.txt ]; then
		echo -e "Aligned IPV4 domains: ${GREEN}$(linecount A/aligned_domains.txt)${NC}"
	fi
	if [ -e A/unaligned_domains.txt ]; then
		echo -e "Unaligned IPV4 domains: ${RED}$(linecount A/unaligned_domains.txt)${NC}"
	fi
	if [ -e AAAA/aligned_IPV6_domains.txt ]; then
		echo -e "Aligned IPV6 domains: ${GREEN}$(linecount AAAA/aligned_IPV6_domains.txt)${NC}"
	fi
	if [ -e AAAA/unaligned_IPV6_domains.txt ]; then
		echo -e "Unaligned IPV6 domains: ${RED}$(linecount AAAA/aligned_IPV6_domains.txt)${NC}"
	fi
	#do a checksum
	nstotal=$(wc -l NS/*.domainlist|grep total|awk '{print $1}')
	resolvingtotal=$(linecount NS/resolving_domains.txt)
	if [[ "$nstotal" != "$resolvingtotal" ]]; then
		echo "Checksum not okay, results may be inaccurate!"
	fi
	echo "Finished! Check your results in: $(basename "$output_dir")"

}

main() {
	filecleanup "$domains_list"

	make_output_dir "$output_dir"

	fetch_dns_records NS "$domains_list"
	analyse_dns_records NS

	if [[ ! -z "$ips_list" ]]; then
		fetch_dns_records A domains_resolving.txt
		analyse_dns_records A
	fi
	if [[ ! -z "$ipv6_list" ]]; then
		fetch_dns_records AAAA domains_resolving.txt
		analyse_dns_records AAAA
	fi

	printSummary

	exit 0
}

#show usage if no parameters are present
[[ $# -eq 0 ]] && usage

#handle parameters
while true; do
	key="$1"
	case "$key" in
		-d|--domainslist)
			domains_list=$(realpath "$2")
			check_file_existence "$domains_list"
			shift # past argument
			;;
		-i|--ipslist)
			ips_list=$(realpath "$2")
			check_file_existence "$ips_list"
			shift # past argument
			;;
		-6|--ipv6list)
			ipv6_list=$(realpath "$2")
			check_file_existence "$ipv6_list"
			shift # past argument
			;;
		-o|--output-dir)
			output_dir=$(realpath "$2")
			shift # past argument
			;;
		-w|--match-www)
			#todo
			shift # past argument
			;;
		-h|--help)
			usage
			;;
		--)
			break
			;;
		*)
			break
			exit 3
	esac
	shift # past argument or value
done

if [[ -n $1 ]]; then
	echo "Last line of file specified as non-opt/last argument:"
	exit 1
fi

if [[ -z "$domains_list" ]]; then
	echo "A list of domains is required!"
	usage
else
	main
fi
